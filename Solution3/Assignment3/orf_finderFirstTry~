#!/usr/bin/perl -wl
use strict;

die "Enter the path to the file as parameter!" unless defined $ARGV[0];
open FILE, $ARGV[0] or die "File does not exist / not a correct path!";

my @seq = <FILE>;
my $sequence;

for(my $i=0;$i<scalar(@seq);$i++){
	$sequence .= $seq[$i];
	chomp $sequence;
}

######### generate complementary reverse sequence:
my $reverseSequence = reverse($sequence);
my $complementaryReverseSequence;

for(my $i=0;$i<length($reverseSequence);$i++){
	if((substr($reverseSequence, $i,1)) eq "A"){
		$complementaryReverseSequence.="T";
	}
	elsif(substr($reverseSequence, $i,1) eq "T"){
		$complementaryReverseSequence.="A";
	}
	elsif(substr($reverseSequence, $i,1) eq "G"){
		$complementaryReverseSequence.="C";
	}
	elsif(substr($reverseSequence, $i,1) eq "C"){
		$complementaryReverseSequence.="G";
	}
}
$reverseSequence = "";
my $maxORFlength = 0;
my $ORFcountFwd = 0;	my $ORFcountRev = 0;	my $ORFcountAll = 0;
my %ORFlengthsFwd;	my %ORFlengthsRev;	my %ORFlengthsAll;
my %ORFpositionsFwd;	my %ORFpositionsRev;	my %ORFpositionsAll;
##### check fwd. strand for ORFs:
while($sequence =~ m/(ATG(.{3})*?(TAG|TGA|TAA))/g) {
	$ORFpositionsFwd{$-[0]} = $+[0];#store the beginning and end of the ORF in a hash
	$ORFpositionsAll{$-[0]} = $+[0];
	$ORFlengthsFwd{length($1)} += 1;
	$ORFlengthsAll{length($1)} += 1;
	$ORFcountFwd++;
	$ORFcountAll++;
	if($maxORFlength<(length($1))){#evaluate the longest ORF, which is neccessary for the histogram
		$maxORFlength = length($1);
	}
}
##### check reverse comp. strand for ORFs:
while($complementaryReverseSequence =~ m/(ATG(.{3})*?(TAG|TGA|TAA))/g) {
	$ORFpositionsRev{$-[0]} = $+[0];#store the beginning and end of the ORF in a hash
	$ORFpositionsAll{$-[0]} = $+[0];
	$ORFlengthsRev{length($1)} += 1;
	$ORFlengthsAll{length($1)} += 1;
	$ORFcountRev++;
	$ORFcountAll++;
	if($maxORFlength<(length($1))){#evaluate the longest ORF, which is neccessary for the histogram
		$maxORFlength = length($1);
	}
}
print "$ORFcountAll ORFs found, $ORFcountFwd on forward, $ORFcountRev on reverse, complementary strand";

###### make histogram:
my $sumOfORFlength;
my $nonemptyORFs = 0;
for(my $i=0;$i<$maxORFlength;$i++){
	my $bar = "";
	for(my $ii=0;$ii<$maxORFlength;$ii++){
		$ORFlengthsAll{$ii} = 0 unless defined $ORFlengthsRev{$ii};
	}
	$sumOfORFlength += $ORFlengthsAll{$i};
	for(my $j=0;$j<$ORFlengthsAll{$i};$j+=2){
		$bar.="x";
	}
	#print "$i: $bar" unless $bar eq "";
	$nonemptyORFs++ unless $bar eq "";
}
#print "$ORFcountAll occurences of an ORF, maxORFlength: $maxORFlength, average length: ".($sumOfORFlength/$nonemptyORFs)."\n";
#print "1 x means there are 2 ORFs of the respective length, ORFs with lengt 0 are overridden by the histogram.\n";

for(my $i=0;$i<$maxORFlength;$i++){
	$ORFlengthsAll{$i} = 0 unless defined $ORFlengthsRev{$i};
}

my $string;

while ( (my $k,my $v) = each %ORFlengthsAll ) {#you may print the bounds and lengths of the reading frames
    $string .= "$k,$v\n";
}

open (MYFILE, '>>/home/tobias/Desktop/out.txt');
print MYFILE $string;
close (MYFILE);

########## Generate random sequence:
my $randomSequence;
for (my $i=0;$i<length($sequence);$i++) {
  my $number=int(rand(4));
  if($number == 0) {
    $randomSequence.="A";
  } elsif ($number == 1) {
    $randomSequence.="C";
  } elsif ($number == 2) {
    $randomSequence.="T";
  } else {
    $randomSequence.="G";
  }
}

########## TODO: put results to database:
