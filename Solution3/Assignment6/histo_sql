#! /usr/bin/perl -w

#Schreiben Sie ein Programm, das ein SQL-Statement generiert, das ein Histogramm
#der Sequenzlängen einer Teilmenge der Sequenzen in der Datenbank erzeugt. Die
#Teilmenge wird durch eine untere und obere Grenze für die Sequenzlänge definiert
#(durch eine WHERE-clause!). Tipp: Benutzen Sie die MySQL-Funktion INTERVAL. (10P)
# Programmname histo_sql
# Input Kommandozeilenparameter -m untere Längen-Grenze
#  -M obere Längen-Grenze
#  -c Anzahl der Intervalle
# Stdin WHERE-clause
# Output Stdout
# MySQL-Statement
# Erweiterungen: • Das Histogramm durch Gnuplot darstellen


use strict;
use LWP::Simple;
use Getopt::Std;
use Scalar::Util qw(looks_like_number);

# Parse CLI options
my %options=();
getopts("m:M:c:",\%options);
# no CGI?
die "Usage: $0 -m <lower bound> -M <upper bound> -c <count intervalls>" unless defined $options{M};
# read CLI defined $options{n} defined $options{s};
my $lowerBound = $options{m};
my $upperBound = $options{M};
my $cIntervall = $options{c};
# not defined CLIs
if(!defined $lowerBound) {
  print "Warning: lower bound not spec!\nAssuming: -m 1\n";
  $lowerBound = "all";
}
if(!defined $cIntervall) {
  print "Warning: intervall size not spec!\nAssuming: -c 1\n";
  $cIntervall = "1";
}
# check legality of input
if((!looks_like_number($lowerBound)) || (!looks_like_number($upperBound)) || (!looks_like_number($cIntervall))) {
  die("args must be values");
}
if (($lowerBound <= 0) || ($upperBound <= 0) || ($cIntervall <= 0)) {
  die("args must be positive values");
}
if($lowerBound > $upperBound) {
  die("lower Bound > upper Bound");
}
# create SQL Statement
print "$lowerBound $upperBound $cIntervall";

