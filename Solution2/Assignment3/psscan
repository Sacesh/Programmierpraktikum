#!/usr/bin/perl -w
use strict;
use LWP::Simple;
#Komandozeilenparameter
my $argc = @ARGV;
#Check if we have at least one argument
die "Usage: $0 <Prosite pattern>" unless $argc == 1;
#The prosite pattern is supplied as CLI arg
my $prositePattern = $ARGV[0];
#...whereas the FASTA input is read from stdin (--> assemble it)
my $fastaHeadline = ""; # The first nonempty line from stdin.
my $fastaData = ""; #Sequence data only
while (<STDIN>) {
	$fastaHeadline = $_ unless $fastaHeadline;
        $fastaData = $fastaData . $_ if $fastaHeadline;
}
chomp($fastaHeadline);
chomp ($fastaData);
#Convert the prosite pattern to a regular expression
$prositePattern =~ s/x/\./g; #Replace x by . (matches any character)
#Process exclusion specifiers like {GA}
$prositePattern =~ s/\{\w+\}/\[\^$1\]/g; #Replace (3) by {3}
#Replace length specifiers. Split into two regexes to improve readability
$prositePattern =~ s/\((\d+)\)/\{$1\}/g; #Replace (3) by {3}
$prositePattern =~ s/\((\d+,\d+)\)/\{$1\}/g; #Replace (3,5) by {3,5}
#We don't need to replace something like [NHG], it's already a regex
#Finally, remove minuses
$prositePattern =~ s/[-]//g;
#Add a global group to be able to match it later
$prositePattern = "(" . $prositePattern . ")";
#
# Matching
#
#Iterate over matches
my $haveMatches = 0;
print "Matches in " . substr($fastaHeadline, 1) . "\n";
#my $startPosition = 0;
#my $endPosition = 0;
while ($fastaData =~ m/$prositePattern/g) {
	my $endPosition = pos $fastaData;
	my $startPosition = $endPosition - length($1);
        print "\t Matched $1, positions $startPosition to $endPosition \n";
	$haveMatches = 1;
}
if(!$haveMatches) { # Didnt find anything
	print "\tNone\n"; 
}
print $prositePattern;