/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package de.bioinformatikmuenchen.pg4.validation;

import java.util.ArrayList;

/**
 *
 * @author schoeffel
 */
public class StrucValiAlg {

    //predicted secondary structure
    private String pred;
    //reference secondary structure
    private String observ;
    //safing intermediate results for Qs
    private double AH;
    private double BH;
    private double AE;
    private double BE;
    private double AC;
    private double BC;
    //safing intermediate results for SOVs
    private double sumSH;
    private double sumSE;
    private double sumSC;
    private double numH;
    private double numE;
    private double numC;
    //lists for overlapping segments
    private ArrayList<VTupel> OvH = new ArrayList();
    private ArrayList<VTupel> OvE = new ArrayList();
    private ArrayList<VTupel> OvC = new ArrayList();
    //lists for not overlapping segments
    private ArrayList<ZTupel> NvH = new ArrayList();
    private ArrayList<ZTupel> NvE = new ArrayList();
    private ArrayList<ZTupel> NvC = new ArrayList();

    public StrucValiAlg(String sec, String pre) {
        assert sec.length() == pre.length();
        pred = pre;
        observ = sec;
        //cutting useless ends generated by GOR
        this.cutends();
        assert sec.length() > 0;
        //counting secondary structure elements
        this.detHelix();
        this.detSheet();
        this.detCoil();
        //determine overlapping segments
        this.detOver('H');
        this.detOver('E');
        this.detOver('C');

    }

    public double getQ3() {
        System.out.println("Number of matches " + (AH + AE + AC));
        System.out.println("Number of comparisons " + (BH + BE + BC));
        if (BH + BE + BC == 0) {
            System.out.println("No Secondary Struture annotated");
            return 0;
        }
        double result = (double) (AH + AE + AC) / (BH + BE + BC) * 100;
        return result;
    }

    public double getQH() {
        if (AH == 0 && BH == 0) {
            System.out.println("AH " + AH + " BH " + BH);
            return 100;
        }
        System.out.println("AH " + AH + " BH " + BH);
        return (double) (AH / BH) * 100;
    }

    public double getQE() {
        if (AE == 0 && BE == 0) {
            System.out.println("AE " + AE + " BE " + BE);
            return 100;
        }
        System.out.println("AE " + AE + " BE " + BE);
        return (double) (AE / BE) * 100;
    }

    public double getQC() {
        if (AC == 0 && BC == 0) {
            System.out.println("AC " + AC + " BC " + BC);
            return 100;
        }
        System.out.println("AC " + AC + " BC " + BC);
        return (double) (AC / BC) * 100;
    }

    public double getSOV() {
        System.out.println("sumS vaules  " + (sumSH + sumSE + sumSC));
        System.out.println("num values " + (numH + numE + numC));
        double result = (double) (sumSH + sumSE + sumSC) / (numH + numE + numC) * 100;
        return result;
    }

    public double getSOVH() {
        System.out.println("sumSH value " + sumSH);
        System.out.println("numH value " + numH);
        double result = (double) sumSH / numH * 100;
        return result;
    }

    public double getSOVE() {
        System.out.println("sumSE value " + sumSE);
        System.out.println("numE value " + numE);
        double result = (double) sumSE / numE * 100;
        return result;
    }

    public double getSOVC() {
        System.out.println("sumSC value " + sumSC);
        System.out.println("numC value " + numC);
        double result = (double) sumSC / numC * 100;
        return result;
    }

    private void detHelix() {
        //correctly predicted helices
        int A = 0;
        //helices in structure
        int B = 0;
        //go through secondary structure sequence
        for (int i = 0; i < pred.length(); i++) {
            if (observ.charAt(i) == 'H') {
                B++;
                if (pred.charAt(i) == 'H') {
                    A++;
                }
            }
        }
        //write into global variables
        AH = A;
        BH = B;
    }

    private void detSheet() {
        //correctly predicted sheet
        int A = 0;
        //sheet in structure
        int B = 0;
        //go through secondary structure sequence
        for (int i = 0; i < pred.length(); i++) {
            if (observ.charAt(i) == 'E') {
                B++;
                if (pred.charAt(i) == 'E') {
                    A++;
                }
            }
        }
        //write into global variables
        AE = A;
        BE = B;
    }

    private void detCoil() {
        //correctly predicted coil
        int A = 0;
        //coil in structure
        int B = 0;
        //go through secondary structure sequence
        for (int i = 0; i < pred.length(); i++) {
            if (observ.charAt(i) == 'C') {
                B++;
                if (pred.charAt(i) == 'C') {
                    A++;
                }
            }
        }
        //write into global variables
        AC = A;
        BC = B;
    }

    private void detOver(char input) {
        //input: char for secondary strucure whichs segment overlapps are to be determined
        //reference to correct segment list
        ArrayList<VTupel> overlapps = OvC;
        ArrayList<ZTupel> noover = NvC;
        if (input == 'H') {
            overlapps = OvH;
            noover = NvH;
        }
        if (input == 'E') {
            overlapps = OvE;
            noover = NvE;
        }
        //list to keep track of segments da need to be added
        //phantom1 tuples are of the form (stao,endo,stap,-1) as they are missing the end position for the overlapp in the prediction
        ArrayList<VTupel> phantom1 = new ArrayList();
        //phantom2 tuples are of the form (stao,-1,stap,endp) as they are missing the end position for the overlapp in the observation
        ArrayList<VTupel> phantom2 = new ArrayList();
        //index for current segments
        int stao = 0;
        int endo;
        int stap = 0;
        int endp;
        //booleans to keep track of segments currenty opened
        boolean seqo = false;
        boolean seqp = false;
        //going through secondary structure observerd / prediction
        for (int i = 0; i < observ.length(); i++) {
            //open segment in observed
            if (observ.charAt(i) == input && seqo == false) {
                stao = i;
                seqo = true;
            }
            //close segment in observ and handle safing indexes
            if (observ.charAt(i) != input && seqo == true) {
                endo = i - 1;
                seqo = false;
                //overlapping segment in predicted goes on further or ends at same position
                if (seqp == true) {
                    //add to list of segments that need to be included later on 
                    phantom2.add(new VTupel(stao, endo, stap, -1));
                } else {
                    //check for overlap
                    if (phantom1.isEmpty()) {
                        //add to no overlapp list
                        noover.add(new ZTupel(stao, endo));
                    }
                }
                //copying overlapps from phantom2 into final overlapp reference
                for (int j = 0; j < phantom2.size(); j++) {
                    overlapps.add(new VTupel(phantom2.get(j).att1, endo, phantom2.get(j).att3, phantom2.get(j).att4));
                }
                //empty phantom2 for next segment
                phantom2.clear();
            }
            //open segment in predicted
            if (pred.charAt(i) == input && seqp == false) {
                stap = i - 1;
                seqp = true;
            }
            //close segment in predicted and handle safing indexes if neccessary
            if (pred.charAt(i) != input && seqp == true) {
                endp = i - 1;
                seqp = false;
                //overlapping segment in observed goes on further 
                if (seqo == true && observ.charAt(i - 1) == input) {
                    //add to list of segments that need to be included later
                    phantom2.add(new VTupel(stao, -1, stap, endp));
                }
                //copying overlapps from phantom1 into final overlapp reference
                for (int j = 0; j < phantom1.size(); j++) {
                    overlapps.add(new VTupel(phantom1.get(j).att1, phantom1.get(j).att2, phantom1.get(j).att3, endp));
                }
                //empty phantom1 for next segment
                phantom1.clear();
            }
            //handling last position
            if (i == observ.length() - 1) {
                //case: segment in observed ends at last position
                if (seqo == true) {
                    endo = observ.length() - 1;
                    //overlapping segment also ends at last position
                    if (pred.charAt(endo) == input) {
                        phantom1.add(new VTupel(stao, endo, stap, -1));
                    }
                    for (int j = 0; j < phantom2.size(); j++) {
                        overlapps.add(new VTupel(phantom2.get(j).att1, endo, phantom2.get(j).att3, phantom2.get(j).att4));
                    }
                }
                if (seqp == true) {
                    endp = observ.length() - 1;
                    for (int j = 0; j < phantom1.size(); j++) {
                        overlapps.add(new VTupel(phantom1.get(j).att1, phantom1.get(j).att2, phantom1.get(j).att3, endp));
                    }
                }
            }
        }
    }

    private void cutends() {
        //initialize cutting borders
        int start = 0;
        int end = pred.length();
        //find first useable position
        while (pred.charAt(start) == '-') {
            start++;
        }
        //find last useable position
        while (pred.charAt(end - 1) == '-') {
            end--;
        }
        //extract useful parts
        pred = pred.substring(start, end);
        observ = observ.substring(start, end);

        System.out.println(observ);
        System.out.println(pred);
    }
}
